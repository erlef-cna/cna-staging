#!/usr/bin/env elixir

Mix.install([
  {:jason, "~> 1.4"},
  {:hex_core, "~> 0.10"}
])

defmodule HexVersions do
  @hex_repo_url "https://repo.hex.pm"

  def fetch_package_versions(package_name) do
    config = %{
      :hex_core.default_config() |
      repo_url: @hex_repo_url,
      repo_name: "hexpm"
    }

    case :hex_repo.get_package(config, package_name) do
      {:ok, {200, _headers, package_data}} ->
        # The releases are in the top-level package_data map with atom key
        releases = Map.get(package_data, :releases, [])
        versions = Enum.map(releases, fn release ->
          # Version is also an atom key
          Map.get(release, :version)
        end)
        {:ok, versions}

      {:ok, {404, _, _}} ->
        {:error, :not_found}

      {:error, reason} ->
        {:error, reason}

      _ ->
        {:error, :unknown}
    end
  end

  def filter_affected_versions(versions, version_ranges) do
    # For OSV, we only care about SEMVER ranges for hex packages
    semver_range = Enum.find(version_ranges, fn r -> r["type"] == "SEMVER" end)

    case semver_range do
      nil ->
        # No semver range, include all versions as a safety measure
        versions

      range ->
        events = Map.get(range, "events", [])
        filter_by_events(versions, events)
    end
  end

  defp filter_by_events(versions, events) do
    # Extract event boundaries
    introduced_version = find_event_version(events, "introduced")
    fixed_version = find_event_version(events, "fixed")
    last_affected_version = find_event_version(events, "last_affected")
    limit_version = find_event_version(events, "limit")

    Enum.filter(versions, fn version ->
      is_affected?(version, introduced_version, fixed_version, last_affected_version, limit_version)
    end)
  end

  defp find_event_version(events, event_type) do
    case Enum.find(events, fn e -> Map.has_key?(e, event_type) end) do
      nil -> nil
      event -> Map.get(event, event_type)
    end
  end

  defp is_affected?(version, introduced, fixed, last_affected, limit) do
    # Check if version is after introduced (if specified)
    after_introduced = case introduced do
      nil -> true
      "0" -> true  # Special case: 0 means all versions
      intro -> Version.compare(version, intro) != :lt
    end

    # Check if version is before fixed (if specified)
    before_fixed = case fixed do
      nil -> true
      fix -> Version.compare(version, fix) == :lt
    end

    # Check if version is before or equal to last_affected (if specified)
    before_last_affected = case last_affected do
      nil -> true
      last -> Version.compare(version, last) != :gt
    end

    # Check if version is before limit (if specified)
    # Limit is used to exclude versions at or after a certain point
    before_limit = case limit do
      nil -> true
      lim -> Version.compare(version, lim) == :lt
    end

    after_introduced and before_fixed and before_last_affected and before_limit
  end
end

defmodule CVEToOSV do
  @doc """
  Converts a CVE record to OSV format.
  Returns {:ok, osv_data} if conversion is successful, {:skip, reason} if should be skipped.
  """
  def convert(cve_data) do
    case should_convert_to_osv?(cve_data) do
      {:ok, :hex_package} -> {:ok, do_convert(cve_data)}
      {:skip, reason} -> {:skip, reason}
    end
  end

  defp should_convert_to_osv?(cve_data) do
    affected = get_in(cve_data, ["containers", "cna", "affected"]) || []

    hex_packages = Enum.filter(affected, fn item ->
      collection_url = Map.get(item, "collectionURL")
      package_name = Map.get(item, "packageName")

      collection_url == "https://repo.hex.pm" and is_binary(package_name)
    end)

    case hex_packages do
      [] -> {:skip, "No hex packages found"}
      [_|_] -> {:ok, :hex_package}
    end
  end

  defp do_convert(cve_data) do
    cve_id = get_in(cve_data, ["cveMetadata", "cveId"])
    cna_data = get_in(cve_data, ["containers", "cna"])

    # Extract basic information
    summary = extract_summary(cna_data)
    details = extract_details(cna_data)
    affected = convert_affected(cna_data)
    references = convert_references(cna_data)
    severity = convert_severity(cna_data)
    credits = convert_credits(cna_data)
    database_specific = convert_database_specific(cna_data)

    # Build aliases
    aliases = [cve_id]
    aliases = add_github_advisory_alias(aliases, references)

    %{
      "schema_version" => "1.7.3",
      "id" => "EEF-#{cve_id}",
      "modified" => format_timestamp(get_in(cve_data, ["cveMetadata", "dateUpdated"]) || get_in(cna_data, ["providerMetadata", "dateUpdated"])),
      "published" => format_timestamp(get_in(cve_data, ["cveMetadata", "datePublished"])),
      "aliases" => aliases,
      "upstream" => [],
      "related" => [],
      "summary" => summary,
      "details" => details,
      "severity" => severity,
      "affected" => affected,
      "references" => references,
      "credits" => credits,
      "database_specific" => database_specific
    }
  end

  defp extract_summary(cna_data) do
    case get_in(cna_data, ["title"]) do
      title when is_binary(title) -> title
      _ ->
        # Fallback to first line of description
        descriptions = get_in(cna_data, ["descriptions"]) || []
        case Enum.find(descriptions, fn desc -> desc["lang"] == "en" end) do
          %{"value" => value} ->
            value
            |> String.split("\n")
            |> List.first()
            |> String.trim()
          _ -> ""
        end
    end
  end

  defp extract_details(cna_data) do
    descriptions = get_in(cna_data, ["descriptions"]) || []
    case Enum.find(descriptions, fn desc -> desc["lang"] == "en" end) do
      %{"value" => value} -> value
      _ -> ""
    end
  end

  defp convert_affected(cna_data) do
    affected_items = get_in(cna_data, ["affected"]) || []

    affected_items
    |> Enum.filter(fn item ->
      Map.get(item, "collectionURL") == "https://repo.hex.pm" and
      is_binary(Map.get(item, "packageName"))
    end)
    |> Enum.map(fn item ->
        package_name = Map.get(item, "packageName")
        repo = Map.get(item, "repo")
        versions = Map.get(item, "versions", [])

        ranges = convert_version_ranges(versions, repo)

        # Fetch actual package versions from hex.pm
        affected_versions = case HexVersions.fetch_package_versions(package_name) do
          {:ok, all_versions} ->
            HexVersions.filter_affected_versions(all_versions, ranges)
          {:error, _reason} ->
            # Fallback to empty list if we can't fetch versions
            []
        end

        %{
          "package" => %{
            "ecosystem" => "Hex",
            "name" => package_name,
            "purl" => "pkg:hex/#{package_name}"
          },
          "ranges" => ranges,
          "versions" => affected_versions
        }
      end)
  end

  defp convert_version_ranges(versions, repo) do
    ranges = []

    # Group versions by type
    versions_by_type = Enum.group_by(versions, fn v -> v["versionType"] end)

    # Convert semver ranges
    ranges = case Map.get(versions_by_type, "semver") do
      nil -> ranges
      semver_versions ->
        semver_range = %{
          "type" => "SEMVER",
          "repo" => repo,
          "events" => convert_semver_events(semver_versions)
        }
        [semver_range | ranges]
    end

    # Convert git ranges
    ranges = case Map.get(versions_by_type, "git") do
      nil -> ranges
      git_versions ->
        git_range = %{
          "type" => "GIT",
          "repo" => repo,
          "events" => convert_git_events(git_versions)
        }
        [git_range | ranges]
    end

    ranges
  end

  defp convert_semver_events(versions) do
    # Group consecutive version entries to build proper ranges
    versions
    |> Enum.flat_map(&convert_single_version_entry/1)
    |> merge_duplicate_events()
    |> sort_events()
  end

  defp convert_single_version_entry(version_entry) do
    status = Map.get(version_entry, "status", "affected")
    version_value = Map.get(version_entry, "version")
    less_than = Map.get(version_entry, "lessThan")
    less_than_or_equal = Map.get(version_entry, "lessThanOrEqual")
    changes = Map.get(version_entry, "changes", [])

    # Clean version strings
    clean_version = fn v -> String.replace(v, ~r/^pkg:hex\/[^@]+@/, "") end

    events = []

    # Handle the base version
    events = case {version_value, status} do
      {nil, _} ->
        events
      {"0", "affected"} ->
        [%{"introduced" => "0"} | events]
      {v, "affected"} when v != "*" ->
        [%{"introduced" => clean_version.(v)} | events]
      {v, "unaffected"} when v != "*" ->
        [%{"fixed" => clean_version.(v)} | events]
      _ ->
        events
    end

    # Handle upper bounds
    events = cond do
      # lessThan with affected = versions < X are affected, so X is fixed
      less_than != nil and less_than != "*" and status == "affected" ->
        [%{"fixed" => clean_version.(less_than)} | events]

      # lessThanOrEqual with affected = versions <= X are affected, so X is last_affected
      less_than_or_equal != nil and less_than_or_equal != "*" and status == "affected" ->
        [%{"last_affected" => clean_version.(less_than_or_equal)} | events]

      # lessThan with unaffected = versions < X are unaffected (unusual but possible)
      less_than != nil and less_than != "*" and status == "unaffected" ->
        [%{"limit" => clean_version.(less_than)} | events]

      # Wildcard lessThan means all versions from version onwards
      less_than == "*" and version_value != nil and version_value != "0" and status == "affected" ->
        # No upper bound needed, the introduced event covers it
        events

      true ->
        events
    end

    # Process changes array for additional fix points
    change_events = Enum.flat_map(changes, fn change ->
      change_status = Map.get(change, "status")
      at_version = Map.get(change, "at")

      case {change_status, at_version} do
        {"unaffected", v} when v != nil -> [%{"fixed" => clean_version.(v)}]
        _ -> []
      end
    end)

    events ++ change_events
  end

  defp merge_duplicate_events(events) do
    # Remove duplicate events, keeping only unique ones
    # This handles cases where multiple version entries create the same event
    Enum.uniq(events)
  end

  defp sort_events(events) do
    # Sort events in canonical order: introduced, fixed, last_affected, limit
    event_order = %{
      "introduced" => 1,
      "fixed" => 2,
      "last_affected" => 3,
      "limit" => 4
    }

    Enum.sort_by(events, fn event ->
      # Find the event type and get its sort order
      event_type = Enum.find(["introduced", "fixed", "last_affected", "limit"], fn key ->
        Map.has_key?(event, key)
      end)

      Map.get(event_order, event_type, 99)
    end)
  end

  defp convert_git_events(versions) do
    # Git versions use commit hashes instead of semantic versions
    versions
    |> Enum.flat_map(&convert_single_git_entry/1)
    |> merge_duplicate_events()
    |> sort_events()
  end

  defp convert_single_git_entry(version_entry) do
    status = Map.get(version_entry, "status", "affected")
    version_value = Map.get(version_entry, "version")
    less_than = Map.get(version_entry, "lessThan")
    less_than_or_equal = Map.get(version_entry, "lessThanOrEqual")
    changes = Map.get(version_entry, "changes", [])

    events = []

    # Handle the base version/commit
    events = case {version_value, status} do
      {nil, _} ->
        events
      {"0", "affected"} ->
        # Special case: "0" means from the beginning
        [%{"introduced" => "0"} | events]
      {v, "affected"} when v != "*" ->
        [%{"introduced" => v} | events]
      {v, "unaffected"} when v != "*" ->
        [%{"fixed" => v} | events]
      _ ->
        events
    end

    # Handle upper bounds (commit ranges)
    events = cond do
      # lessThan with affected = commits before X are affected, so X is fixed
      less_than != nil and less_than != "*" and status == "affected" ->
        [%{"fixed" => less_than} | events]

      # lessThanOrEqual with affected = commits up to X are affected
      less_than_or_equal != nil and less_than_or_equal != "*" and status == "affected" ->
        [%{"last_affected" => less_than_or_equal} | events]

      # lessThan with unaffected = commits before X are unaffected
      less_than != nil and less_than != "*" and status == "unaffected" ->
        [%{"limit" => less_than} | events]

      true ->
        events
    end

    # Process changes array for additional fix commits
    change_events = Enum.flat_map(changes, fn change ->
      change_status = Map.get(change, "status")
      at_commit = Map.get(change, "at")

      case {change_status, at_commit} do
        {"unaffected", c} when c != nil -> [%{"fixed" => c}]
        {"affected", c} when c != nil -> [%{"introduced" => c}]
        _ -> []
      end
    end)

    events ++ change_events
  end

  defp convert_references(cna_data) do
    references = get_in(cna_data, ["references"]) || []

    base_refs = Enum.map(references, fn ref ->
      url = Map.get(ref, "url")
      tags = Map.get(ref, "tags", [])

      type = cond do
        "vendor-advisory" in tags -> "ADVISORY"
        "patch" in tags -> "FIX"
        true -> "WEB"
      end

      %{"type" => type, "url" => url}
    end)

    # Add package URL for hex packages
    affected = get_in(cna_data, ["affected"]) || []
    package_refs = affected
      |> Enum.filter(fn item ->
        Map.get(item, "collectionURL") == "https://repo.hex.pm" and
        is_binary(Map.get(item, "packageName"))
      end)
      |> Enum.map(fn item ->
        package_name = Map.get(item, "packageName")
        %{"type" => "PACKAGE", "url" => "https://hex.pm/packages/#{package_name}"}
      end)

    base_refs ++ package_refs
  end

  defp convert_severity(cna_data) do
    metrics = get_in(cna_data, ["metrics"]) || []

    metrics
    |> Enum.filter(fn metric -> Map.has_key?(metric, "cvssV4_0") end)
    |> Enum.map(fn metric ->
        vector_string = get_in(metric, ["cvssV4_0", "vectorString"])
        %{"type" => "CVSS_V4", "score" => vector_string}
      end)
  end

  defp convert_credits(cna_data) do
    credits = get_in(cna_data, ["credits"]) || []

    Enum.map(credits, fn credit ->
      name = Map.get(credit, "value")
      type_str = Map.get(credit, "type", "")

      # Map CVE credit types to OSV credit types
      osv_type = case type_str do
        "finder" -> "FINDER"
        "reporter" -> "REPORTER"
        "analyst" -> "ANALYST"
        "coordinator" -> "COORDINATOR"
        "remediation developer" -> "REMEDIATION_DEVELOPER"
        "remediation reviewer" -> "REMEDIATION_REVIEWER"
        "remediation verifier" -> "REMEDIATION_VERIFIER"
        "tool" -> "TOOL"
        "sponsor" -> "SPONSOR"
        "other" -> "OTHER"
        _ -> "OTHER"
      end

      %{"name" => name, "type" => osv_type}
    end)
  end

  defp convert_database_specific(cna_data) do
    problem_types = get_in(cna_data, ["problemTypes"]) || []
    impacts = get_in(cna_data, ["impacts"]) || []
    affected = get_in(cna_data, ["affected"]) || []

    # Extract CWE IDs
    cwe_ids = Enum.flat_map(problem_types, fn pt ->
      descriptions = Map.get(pt, "descriptions", [])
      descriptions
      |> Enum.filter(fn desc -> Map.has_key?(desc, "cweId") end)
      |> Enum.map(fn desc -> Map.get(desc, "cweId") end)
    end)

    # Extract CAPEC IDs
    capec_ids = impacts
      |> Enum.filter(fn impact -> Map.has_key?(impact, "capecId") end)
      |> Enum.map(fn impact -> Map.get(impact, "capecId") end)

    # Extract CPE IDs
    cpe_ids = Enum.flat_map(affected, fn item ->
      Map.get(item, "cpes", [])
    end)

    %{
      "cwe_ids" => cwe_ids,
      "capec_ids" => capec_ids,
      "cpe_ids" => cpe_ids
    }
  end

  defp add_github_advisory_alias(aliases, references) do
    github_advisory = Enum.find(references, fn ref ->
      url = Map.get(ref, "url", "")
      String.contains?(url, "github.com") and String.contains?(url, "advisories/GHSA-")
    end)

    case github_advisory do
      %{"url" => url} ->
        case Regex.run(~r/GHSA-[a-z0-9-]+/, url) do
          [ghsa_id] -> [ghsa_id | aliases]
          _ -> aliases
        end
      _ -> aliases
    end
  end

  defp format_timestamp(nil), do: DateTime.utc_now() |> DateTime.to_iso8601()
  defp format_timestamp(timestamp) when is_binary(timestamp) do
    case DateTime.from_iso8601(timestamp) do
      {:ok, dt, _} -> DateTime.to_iso8601(dt)
      _ -> DateTime.utc_now() |> DateTime.to_iso8601()
    end
  end
end

defmodule CLI do
  @records_base_path Path.expand("../records", __DIR__)
  @osv_base_path Path.expand("../osv", __DIR__)
  @reservations_path Path.expand("reservations", @records_base_path)

  def run(argv)

  def run(["convert", file_path]) do
    convert_single_file(file_path)
  end

  def run(["check-all"]) do
    check_all_files()
  end

  def run(["update-versions"]) do
    update_all_versions()
  end

  def run(_args) do
    script_path = :escript.script_name() |> List.to_string()

    IO.puts("""
    Usage: #{script_path} [command]

    Commands:
      convert <file_path> - Convert a single CVE file to OSV format
      check-all           - Check if all CVE files have up-to-date OSV files
      update-versions     - Update affected versions in all OSV files

    Examples:
      #{script_path} convert records/2025/CVE-2025-20759.json
      #{script_path} check-all
      #{script_path} update-versions
    """)
  end

  defp convert_single_file(file_path) do
    unless File.exists?(file_path) do
      IO.puts("Error: File #{file_path} does not exist")
      System.halt(1)
    end

    try do
      content = File.read!(file_path)
      cve_data = Jason.decode!(content)

      case CVEToOSV.convert(cve_data) do
        {:ok, osv_data} ->
          cve_id = get_in(cve_data, ["cveMetadata", "cveId"])
          osv_file_path = Path.join(@osv_base_path, "EEF-#{cve_id}.json")

          formatted_content = Jason.encode!(osv_data, pretty: true, escape: :unicode_safe)
          File.write!(osv_file_path, formatted_content)

          rel_cve_path = Path.relative_to(file_path, repo_root())
          rel_osv_path = Path.relative_to(osv_file_path, repo_root())
          IO.puts("Converted: #{rel_cve_path} -> #{rel_osv_path}")

        {:skip, reason} ->
          rel_path = Path.relative_to(file_path, repo_root())
          IO.puts("Skipped: #{rel_path} (#{reason})")
      end
    rescue
      error ->
        rel_path = Path.relative_to(file_path, repo_root())
        IO.puts("Error processing #{rel_path}: #{Exception.message(error)}")
        System.halt(1)
    end
  end

  defp check_all_files() do
    cve_files = cve_record_paths()

    outdated_files = Enum.reduce(cve_files, [], fn cve_file, acc ->
      case check_file_status(cve_file) do
        {:outdated, osv_file} ->
          rel_cve_path = Path.relative_to(cve_file, repo_root())
          rel_osv_path = Path.relative_to(osv_file, repo_root())
          IO.puts("Outdated: #{rel_cve_path} -> #{rel_osv_path}")
          [cve_file | acc]

        {:missing, osv_file} ->
          rel_cve_path = Path.relative_to(cve_file, repo_root())
          rel_osv_path = Path.relative_to(osv_file, repo_root())
          IO.puts("Missing: #{rel_cve_path} -> #{rel_osv_path}")
          [cve_file | acc]

        {:up_to_date, osv_file} ->
          rel_cve_path = Path.relative_to(cve_file, repo_root())
          rel_osv_path = Path.relative_to(osv_file, repo_root())
          IO.puts("Up to date: #{rel_cve_path} -> #{rel_osv_path}")
          acc

        {:skip, reason} ->
          rel_path = Path.relative_to(cve_file, repo_root())
          IO.puts("Skipped: #{rel_path} (#{reason})")
          acc
      end
    end)

    if length(outdated_files) > 0 do
      IO.puts("\n#{length(outdated_files)} files need updating")
      System.halt(1)
    else
      IO.puts("\nAll files are up to date")
    end
  end

  defp check_file_status(cve_file) do
    try do
      content = File.read!(cve_file)
      cve_data = Jason.decode!(content)

      case CVEToOSV.convert(cve_data) do
        {:ok, osv_data} ->
          cve_id = get_in(cve_data, ["cveMetadata", "cveId"])
          osv_file = Path.join(@osv_base_path, "EEF-#{cve_id}.json")

          if File.exists?(osv_file) do
            existing_content = File.read!(osv_file)
            expected_content = Jason.encode!(osv_data, pretty: true, escape: :unicode_safe)

            if existing_content == expected_content do
              {:up_to_date, osv_file}
            else
              {:outdated, osv_file}
            end
          else
            {:missing, osv_file}
          end

        {:skip, reason} ->
          {:skip, reason}
      end
    rescue
      error ->
        IO.puts("Error processing #{cve_file}: #{Exception.message(error)}")
        {:skip, "processing error"}
    end
  end

  defp cve_record_paths() do
    Path.wildcard(Path.join([@records_base_path, "**", "*.json"])) --
      Path.wildcard(Path.join(@reservations_path, "*.json"))
  end

  defp repo_root() do
    Path.expand("../", __DIR__)
  end

  defp update_all_versions() do
    osv_files = Path.wildcard(Path.join(@osv_base_path, "*.json"))

    updated_count = Enum.reduce(osv_files, 0, fn osv_file, acc ->
      case update_osv_versions(osv_file) do
        :updated ->
          rel_path = Path.relative_to(osv_file, repo_root())
          IO.puts("Updated versions: #{rel_path}")
          acc + 1

        :unchanged ->
          rel_path = Path.relative_to(osv_file, repo_root())
          IO.puts("No version changes: #{rel_path}")
          acc

        {:error, reason} ->
          rel_path = Path.relative_to(osv_file, repo_root())
          IO.puts("Error updating #{rel_path}: #{inspect(reason)}")
          acc
      end
    end)

    if updated_count > 0 do
      IO.puts("\nUpdated #{updated_count} OSV file(s) with new versions")
    else
      IO.puts("\nNo OSV files needed version updates")
    end
  end

  defp update_osv_versions(osv_file) do
    try do
      content = File.read!(osv_file)
      osv_data = Jason.decode!(content)

      # Update versions for each affected package
      updated_affected = Enum.map(osv_data["affected"] || [], fn affected ->
        package_name = get_in(affected, ["package", "name"])
        ranges = Map.get(affected, "ranges", [])

        case HexVersions.fetch_package_versions(package_name) do
          {:ok, all_versions} ->
            new_versions = HexVersions.filter_affected_versions(all_versions, ranges)
            Map.put(affected, "versions", new_versions)

          {:error, _} ->
            # Keep existing versions if we can't fetch
            affected
        end
      end)

      updated_data = Map.put(osv_data, "affected", updated_affected)

      # Check if versions changed
      if updated_data != osv_data do
        # Update modified timestamp
        updated_data = Map.put(updated_data, "modified", format_timestamp(nil))
        formatted_content = Jason.encode!(updated_data, pretty: true, escape: :unicode_safe)
        File.write!(osv_file, formatted_content)
        :updated
      else
        :unchanged
      end
    rescue
      error ->
        {:error, Exception.message(error)}
    end
  end

  defp format_timestamp(nil), do: DateTime.utc_now() |> DateTime.to_iso8601()
  defp format_timestamp(timestamp) when is_binary(timestamp) do
    case DateTime.from_iso8601(timestamp) do
      {:ok, dt, _} -> DateTime.to_iso8601(dt)
      _ -> DateTime.utc_now() |> DateTime.to_iso8601()
    end
  end
end

CLI.run(System.argv())